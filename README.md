# 이동민 202030225

## 3월 29일 
수업 내용

1. 프로젝트 생성시 디렉터리 판별 및 주의 

2. 생성 후 이전 시간에 하던 생성물들 복사 붙여넣기로 하고 자바 생성물 src로 옳긴 후 디버깅 

3. VSC 쓰는 이유는 깊이가 생겨서 쓰기가 편해짐

4. 언어는 2가지 (고급언어, 저급어(기계어, 어셈블리어))가 있다

5. 고급언어는 사람이 이해하기 쉽고 복잡한 작업, 알고리즘을 표현하기 위한 고안된 언어 
    - 기계어는 이진수로 구성된 언어이고 CPU는 기계어만 이해하고 처리가능 
    - 어셈블리어는 니모닉 기호로 일대일 대응시킨 언어

6. 소스는 프로그래밍언어로 작성된 텍스트 파일, 컴파일은 소스파일을 컴퓨터가 이해할 수 있는 기계어로 만드는 과정

7. 플랫폼 = 하드웨어 플랫폼 + 운영체제 플랫폼

8. 프로그램의 플랫폼 호환성 없는 이유 (기계어가 CPU마다 다름, 운영체제마다 API 다름, 체제마다 실행파일 형식이 다름)

9. WORA(write onece run anywhere) 
   - 한번 작성된 코드는 모든 플랫폼에서 바로 실행되는것이 자바 특징
   - C/C++ 등 기존 언어가 가진 플랫폼 종속성 극복
   - 네트워크에 연결된 어느 클라이언트에서나 실행

10. WORA를 가능하개 하는 자바의 특징
    - 바이트코드 (자바 컴파일러로가 자바 소스프로그램을 컴파일한 일종의 기계어)
    - JVM (자바가상기계)

11. 실현 환경: 자바 가상 기계 + 자바 API 라이브러리

12. 응용프로그램 실행
    - main()메소드를 가진 클래스는 main()에서 시작

13. JDK와 JRE (JDK안에는 JRE 포함)

14. JAVA SE의 JDK 구조 확인

15. 사용자 디렉터리 구조 확인

16. 모듈 프로그래밍
    - 자바 응용프로그램을 마치 직소 퍼즐을 연결하듯 필요한 모듈을 연결하는 방식으로 구성

17. 모듈이란 
    - 자바 패키지들과 이미지, XML 파일등의 자원들을 묶은 단위

18. 모듈화
    - JAVA9에서 정의된 새로운 기능

19. 자바 API 
    - JDK에 포함된 클래스 라이브러리 
    - 개발자는 API를 쉽고 빠르게 자바 프로그램 개발

20. 자바 패키지
    - 계층구조로 되어 있음
    - 자바 API는 JDK에 패키지 형로 제공 자진의 패키지 생성 가능
## 코드 블럭
```Java
Public class Foo {
    public static void main(String[] args) {
        System.out.println("Hello!");
   }
}
```
    - 호환성 확인을 위해 관리자 파웨쉘에서 결과 확인

21. 서블릿 
    - 웹서버에서 실행되는 자바 프로그램
    - 서블릿은 사용자 인터페이스를 필요로 하지 않으며 웹 서버에 의해 실행이 제어된다

22. 자바의 특성
    - 플랫폼 독립성 (종속되지 않는 바이트 코드로 플랫폼 독립성)
    - 객체지향 (캡슐화, 다형성 지원)
    - 클래스로 캡슐화 
    (자바의 모든 변수나 메소드는 클래스내에 선언 / 
    클래스 안에서 클래스 (멤버 함수) 작성 가능)
    - 소스와 클래스 파일 (하나의 여러소스에 여러개의 클래스를 작성한 경우 별도의 클래스 파일 생성)

23. 자바 특성2
    - 실행 코드 베포
    - 패키지 
    - 멀티스레드
    - 가비지 컬렉션

24. 자바 특성3
    - 실시간 응용프로그램에 부적합
    - 자바 프로그램은 안전
    - 프로그램 작성 쉬움
    - 실행 속도 개선을 위한 JIT 컴파일러 사용

25. 자바 프로그램의 구조
    - 클래스 만들기
    - 주석문
    - main() 메소드
    - 메소드
    - 변수 선언 
    - 문장
    - 출력

26. 식별자
    - 클래스, 변수, 상수, 메소드 등에 붙이는 이름

27. 대소문자 구별
    - int BarChart;와 int barChart;는 서로 다른 식별자 선언

28. 자바 데이터 타입
    - booleam, char, byte, short, int, long, float, double

29. 래퍼런스 타입
    - 배열에 대한 래퍼런스
    - 클래스에 대한 래퍼런스
    - 인터페이스에 대한 래퍼런스

30. 문자열
    - String 클래스로 문자열 표현
    - 문자열괴 기본타입의 + 연산으로 문자열을 연결한 새로운 문자열 생성

31. 변수
    - 프로그램에 실행중에 값을 임시 저장하는 공간

32. 리터럴
    - 프로그램에서 직접 표현한 값
    - 정수, 실수, 문자, 논리, 문자열, 리터럴이 있음

33. 정수 리터럴
    - 정수 리터럴은 int형으로 컴파일

34. 변수
    - 프로그램 실행 중 값을 임시 저장하기 위한 공간

35. 선언
    - 변수의 타입 크기에 맞게 메모리 할당

36. 실수 리터럴
    - 소수점 형태나 지수 형태로 표편한 실수
    - 실수 타입 리터럴은 더블 타입으로 컨트롤
    - 단일 부호로 표현
    - 특수문저 리터럴은 백슬레시로 시작

37. 논리값 표기

38. null 리터럴
    - 래퍼런스 대입에 사용

39. 문자열 리터럴
    - 이중 인용부호로 묶어 표현
    - 문자열 리터럴(String)은 스트링객체로 자동처리

40. 상수 선언
    - final 키워드 사용
    - 선언시 초깃값 사용
    - 실행 중 변경 불가

41. var 키워드
    - 자바10부터 도입
    - 기존의 변수 선언 방식 : 변수의 타입 반드시 지정
    - 타입 생략하고 변수 선언 가능
    - 컴파일러가 추론하고 변수 타입 결정
    - 지역 변수 선언에만 한정
    - 초깃값이 주어지지 않으면 오류

42. 타입 변환
    - 한 타입의 값을 다른 타입의 값으로 변환

43. 자동 타입 변환
    - 컴파일러에 의해 원래의 타입보다 큰 타입으로 자동 변환

44. 강제 타입 변환
    - 개발자의 의도적 타입 변환
    - ()안에 개발자가 명시적으로 타입 변환 지정
    - 강제 변환은 값 손실 우려

45. System.in
    - 키보드와 연결된 자바의 표준 입력 스트림

46. Scanner 클래스
    - 읽은 바이트를 문자, 정수, 실수, 문자열 등 다양한 타입으로 변환하여 리턴

47. Scanner에서 키 입력 받기
    - Scanner에서 입력되는 키 값을 공백으로 구분되는 토큰 단위로 읽는다

## 코드블럭 (예제 2-5)
```java
import java.util.Scanner;
public class ScannerEx {
  public static void main(String args[]){
    system.out.println("이름, 도시, 나이, 체중, 독신 여부를 빈칸으로 분리하여 입력하세요");
   
    Scanner scanner = new Scanner(System.in);
    string name = scanner.next();
    System.out.println("당신의 이름은 " + name + "입니다.");
    String city = scanner.next();
    System.out.println("당신이 사는 도시는 " + city + "입니다.");
    int age - scanner.nextInt();
    System.out.println("당신의 나이는 " + age + "살입니다.");
    double weight = scanner nextDouble();
    System.out.println("당신의 체중은 " + weight + "kg입니다.");
    boolean single = scanner.nextBoolen();
    System.out.println("당신의 독신여부는 " + single + "입니다.");

    scanner.close();
  }
}
```
48. 연산
    - 주어진 식을 계산하여 결과를 얻어내는 과정

49. 산술 연산자
    - 더하기 빼기 곱하기 나누기 나머지와 응용

50. 증감 연산

51. 대입 연산
    - 연산의 오른쪽 결과는 왼쪽 변수에 대입

52. 비교 연산, 논리 연산

53. 조건 연산
    - 3개의 피연산자로 구성된 삼향(ternary) 연산자

54. 비트 연산 
    - 비트 논리 연산 (비트끼리 AND, OR, XOR, NOT 연산)

55. 조건문 
    - 단순 if 문 
    - if-else 문

56. 다중 if문
    - 조건이 너무 많은 경우 switch 문 사용 권장

57. 중첩 if-else
    - if문이나 else문 혹은 if-else 문에 if나 if-else문을 내포할 수 있다

58. swith문 
    - switch문은 식과 case 문의 값과 비교
    - case의 비교 값과 일치하면 해당 case의 실행 문장 수행

59. break문
    -  break문을 만나면 switch문 벗어남

60. case 문의 값
    - 실수 리터럴은 허용되지 않움
    - 문장, 정수, 문자열 리터럴만 허용 (JDK 1.7부터)

61. 자바 반복문
    - for 문 - 가장 많이 사용하는 반복문
    - while 문 - while문의 조건식은 for문과 동일 조건식이 참인 경우 반복 실행
    - do while 문 - 작업문은 한 번 반드시 실행

62. 중첩 반복
    -  반복문이 다른 반복문을 내포하는 구조

63. 배열
    - 인덱스와 인덱스에 대응하는 데이터들로 이루어진 자료 구조
    - 배열은 같은 타입의 데이터들을 순차적으로 저장되는 공간

64. 배열 선언과 배열 생성의 두 단계 필요
    - 배열 선언 - 이름 선언
    - 배열 생성 - 공간 할당 받는 과정
    - 배열 초기화 - 생성과 값 초기화

65. 배열 인덱스
    - 배열의 인덱스는 0 ~ (배열 크기 -1)

66. length 필드
    - 배열의 크기는 배열 객체의 length 필드에 저장

67. for-each 문
    - 배열이나 나열의 원소를 순차 접근하는데 유용한 for 문
